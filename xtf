#!/bin/bash                   
# xhricma00 Marek Hric
# 07.03.2024


export POSIXLY_CORRECT=yes 
export LC_ALL=C 

usage(){
    echo "Usage: $(basename "$0") [-h|--help] [FILTER] [COMMAND] USER LOG [LOG2 [...]]
        
    COMMAND may be one of:
        list - a listing of records for a given user.
        list-currency - a listing of a sorted list of occurring currencies.
        status - a listing of the actual account status grouped and sorted by currency.
        profit - a statement of the customer's account status with notional profit included.
    FILTER can be a combination of the following:
        -a DATETIME - after: only records AFTER this date and time (without it) are considered. DATETIME is of format YYYY-MM-DD HH:MM:SS.
        -b DATETIME - before: only records BEFORE this date and time (without it) are considered.
        -c CURRENCY - only records corresponding to the given currency are considered.
    -h and --help print a help message with a short description of each command and switch."
    exit 0
}

ab_set_error(){
    # $1 - a or b
    echo "Error: Option $1 set multiple times" >&2
    exit 1
}

two_names_set_error(){
    echo "Error: Two names set" >&2
    exit 1
}

two_commands_error(){
    echo "Error: Two commands set" >&2
    exit 1
}

date_format_error(){
    # $1 - invalid date
    echo "Error: Invalid date format: $1" >&2
    exit 1
}

currency_format_error(){
    # $1 - invalid currency code
    echo "Error: Invalid currency format: $1" >&2
    exit 1
}

regex_check(){
    # $1 - string to be checked
    # $2 - regex
    local checked="$1"
    local regex="$2"

    if [[ $checked =~ $regex ]]; then
        echo true
    else
        echo false
    fi
}

date_validation(){
    # $1 - date to be checked
    local date_regex="^(\d{4})-(0[1-9]|1[0-2])-([0-2][0-9]|3[0-1]) (?:[01][0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9]$"

    valid=$(regex_check "$1" "$date_regex")
    if [ ! "$valid" ]; then
        date_format_error "$1"
    fi

}

currency_validation(){
    # $1 - currency code to be checked
    local currency_regex="^[A-Z]{3}$"

    valid="regex_check $1 $currency_regex"
    if [ ! "$valid" ]; then
        currency_format_error "$1"
    fi

}


if [ -z "$XTF_PROFIT" ]; then
    XTF_PROFIT=20
fi

declare -A currency_table
files=() #array of files

user=''
command=""
a_flag=false
date_filter_after=""
b_flag=false
date_filter_before=""
c_flag_regex=""

while [ -n "$1" ]; do
    case "$1" in 
        -h|--help)
            usage 
            ;;
        -a)
            if [ $a_flag = true ]; then
                ab_set_error "$1"
            fi
            a_flag=true
            shift
            date_validation "$1"
            date_filter_after="$1"
            ;; 
        -b)
            if [ $b_flag = true ]; then
                ab_set_error "$1"
            fi
            b_flag=true
            shift
            date_validation "$1"
            date_filter_before="$1"
            ;;
        -c)
            shift
            currency_validation "$1"
            if [ "$c_flag_regex" == "" ]; then
                c_flag_regex="$1"
            else
                c_flag_regex="$c_flag_regex|$1"
            fi
            ;; 
        list|list-currency|status|profit)
            if [ -z "$command" ]; then
                command="$1"
            else
                two_commands_error 
            fi
           ;;
        *)
            if [ -f "$1" ]; then
                files+=("$1")
            elif [ -z "$user" ]; then
                user="$1"
            else 
                two_names_set_error
            fi
            ;;
    esac
    shift
done

if [ -z "$command" ]; then
    command="list"
fi

if [ -z "$user" ]; then
    echo "Error: No user specified."
    exit 1
fi

if [ ${#files[@]} -eq 0 ]; then
    echo "Error: No log files"
    exit 1
fi


line_regex="^[^;]+;[0-9]{4}-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01]) ([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]);[A-Z]{3};-?[0-9]+(\.[0-9]+)?$"
#line_regex="^.*;(\d{4})-(0[1-9]|1[0-2])-([0-2][0-9]|3[0-1]) (?:[01][0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9];[-+]?[0-9]*\.?[0-9]*$"

#for file in "${files[@]}"; do
#    if [[ "$file" == *.gz ]]; then
#        read="zgrep"
#    else
#        read="grep"
#    fi  
#
#    error=$($read -cvE "$line_regex" "$file")
#    if [ "$error" -gt 0 ]; then
#        echo "Invalid line in log" >&2
#        exit 1
#    fi
#done 

if [ $a_flag = true ]; then
    date_filter_after=$(date -d "$date_filter_after" +"%s")
else 
    date_filter_after=0
fi

if [ $b_flag = true ]; then
    date_filter_before=$(date -d "$date_filter_before" +"%s")
else 
    date_filter_before=$(date -d "9999-12-31 23:59:59" +"%s")
fi

if [ -z "$c_flag_regex" ];then
    c_flag_regex='.*'
else 
    c_flag_regex="^$c_flag_regex$"
fi

error_code=0

if ! awk -v line_regex="$line_regex" '
    ($0 !~ line_regex) {
        print "Line "NR" in file "FILENAME" is not in valid format" > "/dev/stderr"
        error_code=1
    }
    END{
        exit error_code
    }
' "${files[@]}"; then
    exit 1
fi




case "$command" in
    old-list)
        for file in "${files[@]}"; do
            if [[ "$file" == *.gz ]]; then
                grep="zgrep"
            else
                grep="grep"
            fi
            $grep "$user" "$file" | awk -F";" -v a_flag="$a_flag" -v date_after="$date_filter_after" -v b_flag="$b_flag" -v date_before="$date_filter_before"' 
                BEGIN{
                    print "abc"
                }

                {
                    print $2" "date_after

                    date = convert_date_seconds($2);
                    if (a_flag && (date > date_after) && b_flag && (date < date_before)){
                        print $0
                    } else if (a_flag && (date > date_after)){
                        print $0
                    } else if (b_flag && (date < date_before)){
                        print $0
                    } else{
                        print $0
                    }

                    function convert_date_seconds(date_string) {
                        split(date_string, date_parts, /[- :]/)
                        return mktime(date_parts[1] " " date_parts[2] " " date_parts[3] " " date_parts[4] " " date_parts[5] " " date_parts[6])
                    }
                    
                }'
        done
        ;;
    list)
        awk -F";" -v user="$user" -v date_after="$date_filter_after" -v date_before="$date_filter_before" -v currencies="$c_flag_regex" '
            BEGIN{
                # debug
                #print date_before
                #print date_after
            }
            
            {
                if (user != $1) next

                date = convert_date_seconds($2);
                if (date <= date_after) next
                if (date >= date_before) next
                if ($3 !~ currencies) next

                print $0
            }

            function convert_date_seconds(date_string) {
                split(date_string, date_parts, /[- :]/)
                return mktime(date_parts[1] " " date_parts[2] " " date_parts[3] " " date_parts[4] " " date_parts[5] " " date_parts[6])
            }
        ' "${files[@]}" 
        ;;
    list-currency)
        ;;
    status)
        ;;
    profit)
        ;;
esac